<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.16" />


<title>The devil is in the why? - shiv.me</title>
<meta property="og:title" content="The devil is in the why? - shiv.me">



  
  <meta property="description" content="The devil is in the why?">
  






<link rel="stylesheet" href="http://blog.shiv.me/css/main.css" media="all">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400|Lato:400,400italic,700">

  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="http://blog.shiv.me/" class="nav-logo">
    <img src="http://blog.shiv.me/images//images/logo.png" 
         width="50" 
         height="50" 
         alt="shiv.me">
  </a>

  <ul class="nav-links">
    
    <li><a href="http://shiv.me/about/">About</a></li>
    
    <li><a href="http://github.com/shiva">GitHub</a></li>
    
    <li><a href="http://twitter.com/shiva">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">3 min read</span>
    

    <h1 class="article-title">The devil is in the why?</h1>

    
    <span class="article-date">February 14, 2009</span>
    

    <div class="article-content">
      <p>Recently I got asked, what the best way to do a join between two large lists,  into another list was? I always tend to answer that question with: it depends.</p>

<p>Just like any other algorithm, there is no silver bullet. It is a trade off  between CPU and memory utilisation. Sometimes, we do have to think about these  things (this is code in c++ on a device with scarce resources, to say the  least).</p>

<p>Of course, the simplest solution for this would be to use multiple for loops:</p>

<p><code>**// merge - version 1**  
function List&lt;C&gt; merge(List&lt;A&gt; l1, List&lt;B&gt; l2) {</code></p>

<p></p>

<p><code>  // oh god! I shouldn't be doing this  
  for(A a: l1) {  
    C c = new C(a);  
    for(B b: l2) {  
      if (c.foo == b.foo) {  
        c.add(b);  
      }  
    }  
  }  
}  
</code></p>

<p>As is obvious any half-decent programmer would shudder at the thought of writing something like this, particularly let it run on a device with limited resources. A simple way to refactor this would be to create an index for one of the lists and iterate through other.</p>

<p><code>**// merge - version 2**  
function List&lt;C&gt; merge(List&lt;A&gt; l1, List&lt;B&gt; l2) {</code></p>

<p><code>  // create the index  
  HashMap&lt;Foo, Bar&gt; map = new HashMap();  </code></p>

<p><code>  for (B b: l2) {  
    map.put (b.foo, b);  
  }</code></p>

<p><code>  for(A a: l1) {  
    C c = new C(a);  
    c.add(map.get(a.foo));  
  }  
}  
</code><br />
Conventional wisdom says, that version 2 is much better than version 1. Right? Well, what if you have 128 MB of shared memory across your system, but a dedicated processor for your subsystem?! Won&rsquo;t you want to pick version 1 in that case? What if both the lists can have millions of entries? That would render both these cases useless.</p>

<p>Sometimes, before trying to find a technical solution to the problem at hand, it might help to ask why? What is the need for this requirement? The key is to ask why until you reach a specific use-case. I tend to ask this all the way until I reach either a SOAP request, or a specific component in the GUI that requires this piece of data. Most of the time, we can get by without writing a potentially inefficient solution.</p>

<p><a href="http://flickr.com/photos/shvelmur/3262859586/"><img src="http://blog.shiv.me/images/3262859586_5caf14c1fb_m.jpg" alt="Lord of his city" /></a></p>

<p>In this case, after several &ldquo;why&rdquo;s, I discovered that this requirement came about, since one of the products in our suite (yeah we have a bunch of products that build on each other), need to display a list of names of object C, as the user searches for a specific one to add items to. If we had decided to write either v1 or v2, every time the user opened that GUI component, we would transport, a possible 10000 records from the device all the way to the GUI (which in our case is several layers above), when we only need a list of names based on a specific criteria.</p>

<p>The &ldquo;how&rdquo; of your design depends the &ldquo;why&rdquo;. The only limiting factor is the willingness to ask why, until you can find an alternate solution, or, are absolutely convinced that there is no other way to acheive a specific requirement without writing some inefficient code &mdash; then defend rigorously against doing it. well, atleast you have to get a some kind of limits in place.</p>

<p>Sometimes you have to <a href="http://flickr.com/photos/shvelmur/3262859586/">stand up to your product manager</a>, and sometimes you have to take a <a href="http://blog.shiv.me/2009/01/28/i-recommend-drinking-vin-chaude-when-youre-in-strasbourg-france/">sip of warm wine</a>, and go write that &ldquo;piece of crap&rdquo; code.</p>

<p>Happy coding!</p>

    </div>
  </article>

  

</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="http://blog.shiv.me/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="http://blog.shiv.me/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>

    
  </body>
</html>

