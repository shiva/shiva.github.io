<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>In A Day on shiv.me</title>
    <link>http://blog.shiv.me/tags/in-a-day/</link>
    <description>Recent content in In A Day on shiv.me</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright 2016 &amp;copy; Shivanand Velmurugan</copyright>
    <lastBuildDate>Sun, 06 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.shiv.me/tags/in-a-day/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Elixir - A crash course</title>
      <link>http://blog.shiv.me/2016/11/06/elixir-crash-course/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2016/11/06/elixir-crash-course/</guid>
      <description>

&lt;p&gt;These are notes from the &lt;a href=&#34;1&#34; title=&#34;string length != string&#39;s byte size
&#34;&gt;official Elixir documentation&lt;/a&gt;. It a quick walk-through of features in Elixir that are different than C (or C like languages), for someone coming from years of C &amp;ndash; a way for me to remember and use as a reference.&lt;/p&gt;

&lt;h2 id=&#34;types&#34;&gt;Types&lt;/h2&gt;

&lt;h3 id=&#34;atoms&#34;&gt;Atoms&lt;/h3&gt;

&lt;p&gt;Named contants with a value. &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are atoms.&lt;/p&gt;

&lt;h3 id=&#34;strings&#34;&gt;Strings&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Supports unicode string natively! It&amp;rsquo;s about time.&lt;/li&gt;
&lt;li&gt;You can concatenate strings using &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;quot;hello&amp;quot; &amp;lt;&amp;gt; &amp;quot; world&amp;quot;&lt;/code&gt;. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;anonymous-functions&#34;&gt;Anonymous functions&lt;/h3&gt;

&lt;p&gt;Native support for closures &amp;ndash; called anonymous functions. Also, functions are first-class aka can be passed as arguments into other functions. Special syntax is required to invoke ananymous functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(1)&amp;gt; add = fn a,b -&amp;gt; a + b end
#Function&amp;lt;12.52032458/2 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; add.(1,2)
3
iex(3)&amp;gt; mulby2 = fn a -&amp;gt; add.(a,a) end
#Function&amp;lt;6.52032458/1 in :erl_eval.expr/5&amp;gt;
iex(4)&amp;gt; mulby2.(4)
8
iex(5)&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lists&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Native support for lists. hd(list) and tl(list). A list of printable characters will be output as a string. Slower linear access to data, but really fast to prepend elements to the list. eg. &lt;code&gt;[ 0 | list]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tuples&#34;&gt;Tuples&lt;/h3&gt;

&lt;p&gt;Native support for associative arrays. Any pair of values, stored contiguously. Indexes start from zero. mutable &lt;code&gt;put_elem(tuple, idx, &amp;quot;value&amp;quot;)&lt;/code&gt;. Fast access, but expensive to add or insert elements&lt;/p&gt;

&lt;h3 id=&#34;other-types&#34;&gt;Other types&lt;/h3&gt;

&lt;p&gt;Port, Reference and PID&lt;/p&gt;

&lt;h2 id=&#34;operators&#34;&gt;Operators&lt;/h2&gt;

&lt;p&gt;Note that ===, and !== use type when comparing (thankfully, the defaults are sensible)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+, - , ++, &amp;ndash;, &amp;lt;&amp;gt; (concatenate)&lt;/li&gt;
&lt;li&gt;and, or, not&lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp;, ||, !&lt;/li&gt;
&lt;li&gt;==, !=, === (more strict), !== (more strict), &amp;lt;=, &amp;gt;=, &amp;lt; and &amp;gt;&lt;/li&gt;
&lt;li&gt;nil/false == false (everything else is true)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-match-operator&#34;&gt;The match operator (&lt;code&gt;=&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Used to assign result of an operation to a variable. Can also be used to assign a tuple or list to a set of variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{a, b, c} = {:hello, &amp;quot;world&amp;quot;, 42}
[a, b, c] = [1, 2, 3]
[head | tail] = [1, 2, 3]   # head = [1], tail = [2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-pin-operator&#34;&gt;The pin operator (&lt;code&gt;^&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Useful when there is a need to check one of the values of list, but assign another.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; x = 1
1
iex&amp;gt; x = 2
2
iex&amp;gt; x = 1
1
iex&amp;gt; ^x = 2
** (MatchError) no match of right hand side value: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-operator&#34;&gt;The _ operator&lt;/h3&gt;

&lt;p&gt;Ignore the rest, or assign the rest to _&lt;/p&gt;

&lt;p&gt;iex&amp;gt; [h | _] = [1, 2, 3]
[1, 2, 3]
iex&amp;gt; h
1&lt;/p&gt;

&lt;h2 id=&#34;control-structures-conditionals-and-loops&#34;&gt;Control Structures (conditionals and loops)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;case - check for multiple matches&lt;/li&gt;
&lt;li&gt;cond - check for multiple conditions&lt;/li&gt;
&lt;li&gt;if, else, end - check for specific condition&lt;/li&gt;
&lt;li&gt;unless - check for a specific match&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: if and unless are macros and not first class constructs that are part of the language&lt;/p&gt;

&lt;p&gt;Elixir allows a lot of variations of guards that are used in conditional to express conditions. See &lt;a href=&#34;http://elixir-lang.org/getting-started/case-cond-and-if.html#expressions-in-guard-clauses&#34;&gt;here&lt;/a&gt; for more information.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;do/end - the syntax is a bit weird, but quite similar to do..while in C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; if true, do: 1 + 2
3
iex&amp;gt; if false, do: :this, else: :that
:that
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following are equivalent aka &lt;code&gt;end&lt;/code&gt; doesn&amp;rsquo;t really matter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; if true do
...&amp;gt;   a = 1 + 2
...&amp;gt;   a + 10
...&amp;gt; end
13
iex&amp;gt; if true, do: (
...&amp;gt;   a = 1 + 2
...&amp;gt;   a + 10
...&amp;gt; )
13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following would result in a parsing error (is_number that takes two args &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is not found)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; is_number if true do
...&amp;gt;  1 + 2
...&amp;gt; end
** (CompileError) undefined function: is_number/2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be the correct way to acheive the normally &amp;ldquo;expected&amp;rdquo; behaviour&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; is_number(if true do
...&amp;gt;  1 + 2
...&amp;gt; end)
true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;CAUTION&lt;/em&gt;: &lt;code&gt;byte_size(&amp;quot;hellö&amp;quot;) != String.length(&amp;quot;hellö&amp;quot;)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;CAUTION&lt;/em&gt;: (char list) &lt;code&gt;&#39;hello&#39; != &amp;quot;hello&amp;quot;&lt;/code&gt; (string)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;string length != string&amp;rsquo;s byte size
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>