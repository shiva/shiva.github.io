<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shiv.me </title>
    <link>/tags/writing-code/</link>
    <language>en-us</language>
    <author>Shiva Velmurugan</author>
    <rights>(C) 2016</rights>
    <updated>2009-02-14 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>The devil is in the why?</title>
          <link>/2009/02/the-devil-is-in-the-why/</link>
          <pubDate>Sat, 14 Feb 2009 00:00:00 UTC</pubDate>
          <author>Shiva Velmurugan</author>
          <guid>/2009/02/the-devil-is-in-the-why/</guid>
          <description>&lt;p&gt;Recently I got asked, what the best way to do a join between two large lists,  into another list was? I always tend to answer that question with: it depends.&lt;/p&gt;

&lt;p&gt;Just like any other algorithm, there is no silver bullet. It is a trade off  between CPU and memory utilisation. Sometimes, we do have to think about these  things (this is code in c++ on a device with scarce resources, to say the  least).&lt;/p&gt;

&lt;p&gt;Of course, the simplest solution for this would be to use multiple for loops:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;**// merge - version 1**  
function List&amp;lt;C&amp;gt; merge(List&amp;lt;A&amp;gt; l1, List&amp;lt;B&amp;gt; l2) {&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;  // oh god! I shouldn&#39;t be doing this  
  for(A a: l1) {  
    C c = new C(a);  
    for(B b: l2) {  
      if (c.foo == b.foo) {  
        c.add(b);  
      }  
    }  
  }  
}  
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As is obvious any half-decent programmer would shudder at the thought of writing something like this, particularly let it run on a device with limited resources. A simple way to refactor this would be to create an index for one of the lists and iterate through other.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;**// merge - version 2**  
function List&amp;lt;C&amp;gt; merge(List&amp;lt;A&amp;gt; l1, List&amp;lt;B&amp;gt; l2) {&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;  // create the index  
  HashMap&amp;lt;Foo, Bar&amp;gt; map = new HashMap();  &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;  for (B b: l2) {  
    map.put (b.foo, b);  
  }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;  for(A a: l1) {  
    C c = new C(a);  
    c.add(map.get(a.foo));  
  }  
}  
&lt;/code&gt;&lt;br /&gt;
Conventional wisdom says, that version 2 is much better than version 1. Right? Well, what if you have 128 MB of shared memory across your system, but a dedicated processor for your subsystem?! Won&amp;rsquo;t you want to pick version 1 in that case? What if both the lists can have millions of entries? That would render both these cases useless.&lt;/p&gt;

&lt;p&gt;Sometimes, before trying to find a technical solution to the problem at hand, it might help to ask why? What is the need for this requirement? The key is to ask why until you reach a specific use-case. I tend to ask this all the way until I reach either a SOAP request, or a specific component in the GUI that requires this piece of data. Most of the time, we can get by without writing a potentially inefficient solution.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://flickr.com/photos/shvelmur/3262859586/&#34;&gt;&lt;img src=&#34;/images/3262859586_5caf14c1fb_m.jpg&#34; alt=&#34;Lord of his city&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this case, after several &amp;ldquo;why&amp;rdquo;s, I discovered that this requirement came about, since one of the products in our suite (yeah we have a bunch of products that build on each other), need to display a list of names of object C, as the user searches for a specific one to add items to. If we had decided to write either v1 or v2, every time the user opened that GUI component, we would transport, a possible 10000 records from the device all the way to the GUI (which in our case is several layers above), when we only need a list of names based on a specific criteria.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;how&amp;rdquo; of your design depends the &amp;ldquo;why&amp;rdquo;. The only limiting factor is the willingness to ask why, until you can find an alternate solution, or, are absolutely convinced that there is no other way to acheive a specific requirement without writing some inefficient code &amp;mdash; then defend rigorously against doing it. well, atleast you have to get a some kind of limits in place.&lt;/p&gt;

&lt;p&gt;Sometimes you have to &lt;a href=&#34;http://flickr.com/photos/shvelmur/3262859586/&#34;&gt;stand up to your product manager&lt;/a&gt;, and sometimes you have to take a [sip of warm wine][1], and go write that &amp;ldquo;piece of crap&amp;rdquo; code.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;p&gt;[1]: &lt;a href=&#34;http://blog.shiv.me/2009/01/28/i-recommend-drinking-vin-chaude-when-youre-in-strasbourg-france/&#34;&gt;http://blog.shiv.me/2009/01/28/i-recommend-drinking-vin-chaude-when-youre-in-strasbourg-france/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
