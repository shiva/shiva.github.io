<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shiv.me </title>
    <link>http://blog.shiv.me/tags/elixir/</link>
    <language>en-us</language>
    <author>Shiva Velmurugan</author>
    <rights>(C) 2016</rights>
    <updated>2016-11-06 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>Elixir - Basics</title>
          <link>http://blog.shiv.me/2016/11/06/elixir-types-and-operators/</link>
          <pubDate>Sun, 06 Nov 2016 00:00:00 UTC</pubDate>
          <author>Shiva Velmurugan</author>
          <guid>http://blog.shiv.me/2016/11/06/elixir-types-and-operators/</guid>
          <description>

&lt;h1 id=&#34;types&#34;&gt;Types&lt;/h1&gt;

&lt;h2 id=&#34;atoms&#34;&gt;Atoms&lt;/h2&gt;

&lt;p&gt;Named contants with a value. &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are atoms.&lt;/p&gt;

&lt;h2 id=&#34;strings&#34;&gt;Strings&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Supports unicode string natively! It&amp;rsquo;s about time.&lt;/li&gt;
&lt;li&gt;You can concatenate strings using &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;quot;hello&amp;quot; &amp;lt;&amp;gt; &amp;quot; world&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CAUTION&lt;/em&gt;: &lt;code&gt;byte_size(&amp;quot;hellö&amp;quot;) != String.length(&amp;quot;hellö&amp;quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CAUTION&lt;/em&gt;: (char list) &lt;code&gt;&#39;hello&#39; != &amp;quot;hello&amp;quot;&lt;/code&gt; (string)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;anonymous-functions&#34;&gt;Anonymous functions&lt;/h2&gt;

&lt;p&gt;Native support for closures &amp;ndash; called anonymous functions. Also, functions are first-class aka can be passed as arguments into other functions. Special syntax is required to invoke ananymous functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(1)&amp;gt; add = fn a,b -&amp;gt; a + b end
#Function&amp;lt;12.52032458/2 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; add.(1,2)
3
iex(3)&amp;gt; mulby2 = fn a -&amp;gt; add.(a,a) end
#Function&amp;lt;6.52032458/1 in :erl_eval.expr/5&amp;gt;
iex(4)&amp;gt; mulby2.(4)
8
iex(5)&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lists&#34;&gt;Lists&lt;/h2&gt;

&lt;p&gt;Native support for lists. hd(list) and tl(list). A list of printable characters will be output as a string. Slower linear access to data, but really fast to prepend elements to the list. eg. &lt;code&gt;[ 0 | list]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tuples&#34;&gt;Tuples&lt;/h2&gt;

&lt;p&gt;Native support for associative arrays. Any pair of values, stored contiguously. Indexes start from zero. mutable &lt;code&gt;put_elem(tuple, idx, &amp;quot;value&amp;quot;)&lt;/code&gt;. Fast access, but expensive to add or insert elements&lt;/p&gt;

&lt;h2 id=&#34;others&#34;&gt;Others&lt;/h2&gt;

&lt;p&gt;Port, Reference and PID&lt;/p&gt;

&lt;h1 id=&#34;operations&#34;&gt;Operations&lt;/h1&gt;

&lt;p&gt;Note that ===, and !== use type when comparing (thankfully, the defaults are sensible)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+, - , ++, &amp;ndash;, &amp;lt;&amp;gt; (concatenate)&lt;/li&gt;
&lt;li&gt;and, or, not&lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp;, ||, !&lt;/li&gt;
&lt;li&gt;==, !=, === (more strict), !== (more strict), &amp;lt;=, &amp;gt;=, &amp;lt; and &amp;gt;&lt;/li&gt;
&lt;li&gt;nil/false == false (everything else is true)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    

  </channel>
</rss>
