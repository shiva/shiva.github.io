<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elixir on shiv.me</title>
    <link>http://blog.shiv.me/tags/elixir/</link>
    <description>Recent content in Elixir on shiv.me</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright 2016 &amp;copy; Shivanand Velmurugan</copyright>
    <lastBuildDate>Sun, 06 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.shiv.me/tags/elixir/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Elixir - A crash course</title>
      <link>http://blog.shiv.me/2016/11/06/elixir-crash-course/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2016/11/06/elixir-crash-course/</guid>
      <description>

&lt;p&gt;These are notes from the &lt;a href=&#34;1&#34; title=&#34;`byte_size(&amp;quot;hellö&amp;quot;) != String.length(&amp;quot;hellö&amp;quot;)`. Also, (char list) `&#39;hello&#39; != &amp;quot;hello&amp;quot;` (string)
&#34;&gt;official Elixir documentation&lt;/a&gt;. It a quick walk-through of features in Elixir that are different than C (or C like languages), for someone coming from years of C &amp;ndash; a way for me to remember and use as a reference.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#types&#34;&gt;Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#control-structures&#34;&gt;Control Structures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;types&#34;&gt;Types&lt;/h2&gt;

&lt;h3 id=&#34;atoms&#34;&gt;Atoms&lt;/h3&gt;

&lt;p&gt;Named contants with a value. &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are atoms.&lt;/p&gt;

&lt;h3 id=&#34;strings&#34;&gt;Strings&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Supports unicode string natively! It&amp;rsquo;s about time.&lt;/li&gt;
&lt;li&gt;You can concatenate strings using &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;quot;hello&amp;quot; &amp;lt;&amp;gt; &amp;quot; world&amp;quot;&lt;/code&gt;. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;anonymous-functions&#34;&gt;Anonymous functions&lt;/h3&gt;

&lt;p&gt;Native support for closures &amp;ndash; called anonymous functions. Also, functions are first-class aka can be passed as arguments into other functions. Special syntax is required to invoke ananymous functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(1)&amp;gt; add = fn a,b -&amp;gt; a + b end
#Function&amp;lt;12.52032458/2 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; add.(1,2)
3
iex(3)&amp;gt; mulby2 = fn a -&amp;gt; add.(a,a) end
#Function&amp;lt;6.52032458/1 in :erl_eval.expr/5&amp;gt;
iex(4)&amp;gt; mulby2.(4)
8
iex(5)&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lists&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Native support for lists. hd(list) and tl(list). A list of printable characters will be output as a string. Slower linear access to data, but really fast to prepend elements to the list. eg. &lt;code&gt;[ 0 | list]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tuples&#34;&gt;Tuples&lt;/h3&gt;

&lt;p&gt;Native support for associative arrays. Any pair of values, stored contiguously. Indexes start from zero. mutable &lt;code&gt;put_elem(tuple, idx, &amp;quot;value&amp;quot;)&lt;/code&gt;. Fast access, but expensive to add or insert elements&lt;/p&gt;

&lt;h3 id=&#34;keyword-lists&#34;&gt;Keyword Lists&lt;/h3&gt;

&lt;p&gt;Lists of tuples where
 - Keys must be atoms.
 - Keys are ordered, as specified by the developer.
 - Keys can be given more than once.&lt;/p&gt;

&lt;p&gt;Useful for making DSLs.&lt;/p&gt;

&lt;p&gt;Elixir has special syntax for keyword lists&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; list = [{:a, 1}, {:b, 2}]
[a: 1, b: 2]
iex&amp;gt; list ++ [c: 3]
[a: 1, b: 2, c: 3]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;a href=&#34;3&#34; title=&#34;`if` and `unless` are macros and not first class constructs that are part of the language
&#34;&gt;Keyword&lt;/a&gt; module provides methods to manipulate keyword lists.&lt;/p&gt;

&lt;h3 id=&#34;maps-2&#34;&gt;Maps &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;For a key-value store, maps are the “go to” data structure in Elixir. A map is created using the %{} syntax:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maps allow any value as a key.&lt;/li&gt;
&lt;li&gt;Maps’ keys do not follow any ordering.&lt;/li&gt;
&lt;li&gt;Matches a subset of a given value.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; iex&amp;gt; map = %{:a =&amp;gt; 1, 2 =&amp;gt; :b}
 %{2 =&amp;gt; :b, :a =&amp;gt; 1}
 iex&amp;gt; map[:a]
 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Matches as long as a key is found in the map.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; iex&amp;gt; %{:a =&amp;gt; a} = %{:a =&amp;gt; 1, 2 =&amp;gt; :b}
 %{2 =&amp;gt; :b, :a =&amp;gt; 1}
 iex&amp;gt; a
 1
 iex&amp;gt; n = 1
 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Variables can be used when accessing, matching and adding keys&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; iex&amp;gt; map = %{n =&amp;gt; :one}
 %{1 =&amp;gt; :one}
 iex&amp;gt; map[n]
 :one
 iex&amp;gt; %{^n =&amp;gt; :one} = %{1 =&amp;gt; :one, 2 =&amp;gt; :two, 3 =&amp;gt; :three}
 %{1 =&amp;gt; :one, 2 =&amp;gt; :two, 3 =&amp;gt; :three}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;If all the keys are atoms, convienience syntax may be used.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; iex&amp;gt; map = %{:a =&amp;gt; 1, 2 =&amp;gt; :b}
 %{2 =&amp;gt; :b, :a =&amp;gt; 1}

 iex&amp;gt; map.a
 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Map.html&#34;&gt;Map&lt;/a&gt; module provides a very similar API to the Keyword module with convenience functions to manipulate maps.&lt;/p&gt;

&lt;h3 id=&#34;nested-data-structures&#34;&gt;Nested data structures&lt;/h3&gt;

&lt;p&gt;Elixir supported special functions for working with nested structures. xpath like addressing into a specific level in a nested struct&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/2&#34;&gt;put_in/2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Kernel.html#update_in/2&#34;&gt;update_in/2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Kernel.html#get_update_in/2&#34;&gt;get_update_in/2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dynamic variants of the above:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Kernel.html#put_in/3&#34;&gt;put_in/3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Kernel.html#update_in/3&#34;&gt;update_in/3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/Kernel.html#get_update_in/3&#34;&gt;get_update_in/3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;other-types&#34;&gt;Other types&lt;/h3&gt;

&lt;p&gt;Port, Reference and PID&lt;/p&gt;

&lt;h2 id=&#34;operators&#34;&gt;Operators&lt;/h2&gt;

&lt;p&gt;Note that ===, and !== use type when comparing (thankfully, the defaults are sensible)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+, - , ++, &amp;ndash;, &amp;lt;&amp;gt; (concatenate)&lt;/li&gt;
&lt;li&gt;and, or, not&lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp;, ||, !&lt;/li&gt;
&lt;li&gt;==, !=, === (more strict), !== (more strict), &amp;lt;=, &amp;gt;=, &amp;lt; and &amp;gt;&lt;/li&gt;
&lt;li&gt;nil/false == false (everything else is true)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-match-operator&#34;&gt;The match operator (&lt;code&gt;=&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Used to assign result of an operation to a variable. Can also be used to assign a tuple or list to a set of variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{a, b, c} = {:hello, &amp;quot;world&amp;quot;, 42}
[a, b, c] = [1, 2, 3]
[head | tail] = [1, 2, 3]   # head = [1], tail = [2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-pin-operator&#34;&gt;The pin operator (&lt;code&gt;^&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Useful when there is a need to check one of the values of list, but assign another.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; x = 1
1
iex&amp;gt; x = 2
2
iex&amp;gt; x = 1
1
iex&amp;gt; ^x = 2
** (MatchError) no match of right hand side value: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-operator&#34;&gt;The _ operator&lt;/h3&gt;

&lt;p&gt;Ignore the rest, or assign the rest to _&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; [h | _] = [1, 2, 3]
[1, 2, 3]
iex&amp;gt; h
1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;control-structures&#34;&gt;Control Structures&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;case - check for multiple matches.&lt;/li&gt;
&lt;li&gt;cond - check for multiple conditions.&lt;/li&gt;
&lt;li&gt;if, else, end - check for specific condition.&lt;/li&gt;
&lt;li&gt;unless - check for a specific match. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir allows a lot of variations of guards that are used in conditional to express conditions. See &lt;a href=&#34;2&#34; title=&#34;Maps are supported from Elixir v1.2. For previous versions, use the [HashDict][5] module
&#34;&gt;here&lt;/a&gt; for more information.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;do/end - the syntax is a bit weird, but quite similar to do..while in C. They are just keyword lists.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; if true, do: 1 + 2
3
iex&amp;gt; if false, do: :this, else: :that
:that
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following are equivalent aka &lt;code&gt;end&lt;/code&gt; doesn&amp;rsquo;t really matter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; if true do
...&amp;gt;   a = 1 + 2
...&amp;gt;   a + 10
...&amp;gt; end
13
iex&amp;gt; if true, do: (
...&amp;gt;   a = 1 + 2
...&amp;gt;   a + 10
...&amp;gt; )
13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following would result in a parsing error (is_number that takes two args &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is not found)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; is_number if true do
...&amp;gt;  1 + 2
...&amp;gt; end
** (CompileError) undefined function: is_number/2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be the correct way to acheive the normally &amp;ldquo;expected&amp;rdquo; behaviour&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex&amp;gt; is_number(if true do
...&amp;gt;  1 + 2
...&amp;gt; end)
true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;code&gt;byte_size(&amp;quot;hellö&amp;quot;) != String.length(&amp;quot;hellö&amp;quot;)&lt;/code&gt;. Also, (char list) &lt;code&gt;&#39;hello&#39; != &amp;quot;hello&amp;quot;&lt;/code&gt; (string)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩︎︎&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Maps are supported from Elixir v1.2. For previous versions, use the &lt;a href=&#34;http://elixir-lang.org/docs/stable/elixir/HashDict.html&#34;&gt;HashDict&lt;/a&gt; module
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;↩︎︎&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; are macros and not first class constructs that are part of the language
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;↩︎︎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>