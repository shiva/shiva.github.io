<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>unix on Rabble-rousing Rambling</title>
    <link>http://blog.shiv.me/tags/unix/</link>
    <description>Recent content in unix on Rabble-rousing Rambling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright 2016 &amp;copy; Shivanand Velmurugan</copyright>
    <lastBuildDate>Mon, 31 Mar 2014 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.shiv.me/tags/unix/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting git status on multiple directories</title>
      <link>http://blog.shiv.me/2014/03/31/getting-git-status-on-multiple-directories/</link>
      <pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2014/03/31/getting-git-status-on-multiple-directories/</guid>
      <description>At any given time, I have a handful of git repositories that I work on. While typing in the command-line is great, it getting tiring when you have a several directories that you have to manually change to and check. The &amp;ldquo;git status&amp;rdquo; command can take the git repo and the working directory as input. That, and a little bash programming to the rescue. The following command, executes git status in every subdirectory that is a git repository.</description>
    </item>
    
    <item>
      <title>Working with rpms (extract, list contents)</title>
      <link>http://blog.shiv.me/2013/02/17/working-with-rpms-extract-list-contents/</link>
      <pubDate>Sun, 17 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2013/02/17/working-with-rpms-extract-list-contents/</guid>
      <description>Unix. I love thee!
Extract an rpm without installing in to the current directory (really, the rpm command should support this):
$ rpm2cpio myrpmfile.rpm | cpio -idmv
*i: Restore archive
*d: Create leading directories where needed
*m: Retain previous file modification times when creating files
*v: Verbose i.e. display progress
List contents of an rpm:
$ rpm -qlp myrpmfile.rpm 
source</description>
    </item>
    
    <item>
      <title>More unix goodness</title>
      <link>http://blog.shiv.me/2012/05/21/more-unix-goodness/</link>
      <pubDate>Mon, 21 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2012/05/21/more-unix-goodness/</guid>
      <description>Ohh the unix command prompt, I love thee! Can you guess what these commands do?
# grep -l &amp;lt;regex&amp;gt;  # find . -name &amp;lt;regex&amp;gt; -delete  </description>
    </item>
    
    <item>
      <title>Life in the BASH universe</title>
      <link>http://blog.shiv.me/2011/08/28/life-in-the-bash-universe/</link>
      <pubDate>Sun, 28 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2011/08/28/life-in-the-bash-universe/</guid>
      <description>If you write a lot of scripts to automate tasks, you probably already know this. However, if you don&amp;rsquo;t, and you are still reading, you are probably a programmer, in which case, you really should be learning how to script in BASH!
A couple of pointers for you:
1. Using a -x, in the shebang line &amp;ldquo;echo&amp;quot;s every line before executing. This turns out to be quite useful for debugging shell scripts</description>
    </item>
    
    <item>
      <title>Exporting XDisplay</title>
      <link>http://blog.shiv.me/2011/06/21/exporting-xdisplay/</link>
      <pubDate>Tue, 21 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2011/06/21/exporting-xdisplay/</guid>
      <description>In *nix systems, you can make the display, the GUI of an application, appear on another machine. This if often required, when the machine you want to run the application on is in a lab, and you have access through a desktop machine that has a monitor.
You can do this, by running an XServer on the desktop machine and configuring the client (the one where you run your app) with the XServer details.</description>
    </item>
    
    <item>
      <title>Job Control on \*NIX systems</title>
      <link>http://blog.shiv.me/2011/01/31/job-control-on-%5Cnix-systems/</link>
      <pubDate>Mon, 31 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2011/01/31/job-control-on-%5Cnix-systems/</guid>
      <description>If you are not a UNIX user/not a geek, please turn away right now.
Every year, I either chance upon something new, or remind myself of something interesting that I&amp;rsquo;ve forgotten. This is the latter case. On a *NIX shell, you can push a foreground process to background (obviously without terminating it):
$ ./someprocess ... ... ... Ctrl-Z [1]+ Stopped ./someprocess $ bg [1]+ ./someprocess &amp;amp;
To bring the process into foreground:</description>
    </item>
    
    <item>
      <title>Unix: removing duplicates from a file</title>
      <link>http://blog.shiv.me/2008/09/09/unix-removing-duplicates-from-a-file/</link>
      <pubDate>Tue, 09 Sep 2008 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2008/09/09/unix-removing-duplicates-from-a-file/</guid>
      <description>Over the last few months, I have re-discovered some unix commands (it&amp;rsquo;s been such a long time)
 Eliminate duplicate lines from a file   #sort -u filename &amp;gt; filename.new
  List all lines that do not match a condition   #grep -v ajsk filename
  Copy contents of two files to one   #cat file1 file2 &amp;gt; file3
  Append output of a command to a file   #cat file1 &amp;gt;&amp;gt; file2</description>
    </item>
    
    <item>
      <title>cvs - Getting list of files changed in the current tree</title>
      <link>http://blog.shiv.me/2008/06/23/cvs-getting-list-of-files-changed-in-the-current-tree/</link>
      <pubDate>Mon, 23 Jun 2008 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2008/06/23/cvs-getting-list-of-files-changed-in-the-current-tree/</guid>
      <description>The simple way to retreive the list of changed files would be to update the tree, which would then list the files updated.
#cvs update . &amp;gt; filelist.dat
The problem with this, is that if there have been changes to other files after your last update, you will have to manually glean the files that you have changed. I tend face this, particularly during the last couple of weeks before a release, since you don&amp;rsquo;t want to risk updating your tree everyday, but still have to make 2/3 checkins.</description>
    </item>
    
    <item>
      <title>Unix: how to check system configuration on solaris</title>
      <link>http://blog.shiv.me/2007/09/08/unix-how-to-check-system-configuration-on-solaris/</link>
      <pubDate>Sat, 08 Sep 2007 00:00:00 +0000</pubDate>
      
      <guid>http://blog.shiv.me/2007/09/08/unix-how-to-check-system-configuration-on-solaris/</guid>
      <description>I had to compare machine hardware today, and found information on that here.
**#prtdiag -v - **Gives hardware information about FSB, Sparc Model, CPU speed, RAM, Harddisks, USB drives (ie. PCI and networking slots) etc.
Click on the image below, for a detailed overview of prtdiag&amp;rsquo;s output

#psrinfo -p - lists number of physical processors .
#psrinfo -p -v - list number of virtual processors (cores) per physical processor.</description>
    </item>
    
  </channel>
</rss>
